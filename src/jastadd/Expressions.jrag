import soot.jimple.IntConstant;
import soot.jimple.LongConstant;


aspect Expressions {


	public static int Expr.temp = 0;
	
	public static void Expr.setTempIdx(int i) {
		Expr.temp = i;
	}
		
	public static int Expr.getTempIdx() {
		return Expr.temp++;
	}
	
	public Local Expr.getTempLocal(Body b) {
		Local local = Jimple.v().newLocal("temp$" + this.getTempIdx(), this.type().sootType());
		b.getLocals().add(local);
		return local;
	}
	
	// abstract general case
	public soot.Value Expr.emit(Body b) { 
		throw new Error("Operation emit not supported for " + getClass().getName());
	}
	
	public soot.Value IntegerLiteral.emit(Body b) {
		return soot.jimple.IntConstant.v(constant().intValue());
	}
	
	//TODO: Soot doesn't have a CharConstant... maybe add one?
	public soot.Value CharacterLiteral.emit(Body b) {
		return soot.jimple.IntConstant.v(constant().intValue());
	}
	
	public soot.Value LongLiteral.emit(Body b) {
		return soot.jimple.LongConstant.v(constant().longValue());
	}
	
	public soot.Value FloatingPointLiteral.emit(Body b) {
		return soot.jimple.FloatConstant.v(constant().floatValue());
	}
	
	public soot.Value DoubleLiteral.emit(Body b) {
		return soot.jimple.DoubleConstant.v(constant().doubleValue());
	}
	
	public soot.Value StringLiteral.emit(Body b) {
		return soot.jimple.StringConstant.v(getLITERAL());
	}
	
	public soot.Value NullLiteral.emit(Body b) {
		return soot.jimple.NullConstant.v();
	}
	
	//TODO: Soot doesn't have a BooleanConstant... maybe add one?
	public soot.Value BooleanLiteral.emit(Body b) {
		return soot.jimple.IntConstant.v(constant().booleanValue() ? 1 : 0);
	}
	
	public soot.Value ParExpr.emit(Body b) {
		return getExpr().emit(b);
	}
	
	//General case... for binary operations
	public soot.Value Binary.emit(Body b) {
		throw new Error("emitOperation not implemented in " + getClass().getName());
	}
	
	public Local Binary.getLeftOperandLocal(Body b) {
		soot.Value lhs = this.getLeftOperand().emit(b);
		Local lhsLocal = this.getTempLocal(b);
		Chain units = b.getUnits();
		units.add(Jimple.v().newAssignStmt(lhsLocal, lhs));
		return lhsLocal;
	}
	
	public Local Binary.getRightOperandLocal(Body b) {
		soot.Value rhs = this.getRightOperand().emit(b);
		Local rhsLocal = this.getTempLocal(b);
		Chain units = b.getUnits();
		units.add(Jimple.v().newAssignStmt(rhsLocal, rhs));
		return rhsLocal;
	}
	
	//TODO:
	public void AssignExpr.getDestLocal(Body b) {
		//interesting because destination is an address...
		//soot.Value dest = this.getDest().
		return;
	}

	public soot.Value AddExpr.emit(Body b) {
		Local lhs = this.getLeftOperandLocal(b);
		Local rhs = this.getRightOperandLocal(b);
		soot.jimple.AddExpr retval = Jimple.v().newAddExpr(lhs, rhs);
		return retval;
	}
	
	public soot.Value SubExpr.emit(Body b) {
		Local lhs = this.getLeftOperandLocal(b);
		Local rhs = this.getRightOperandLocal(b);
		soot.jimple.SubExpr retval = Jimple.v().newSubExpr(lhs, rhs);
		return retval;
	}
	
	public soot.Value MulExpr.emit(Body b) {
		Local lhs = this.getLeftOperandLocal(b);
		Local rhs = this.getRightOperandLocal(b);
		soot.jimple.MulExpr retval = Jimple.v().newMulExpr(lhs, rhs);
		return retval;
	}
	
	public soot.Value DivExpr.emit(Body b) {
		Local lhs = this.getLeftOperandLocal(b);
		Local rhs = this.getRightOperandLocal(b);
		soot.jimple.DivExpr retval = Jimple.v().newDivExpr(lhs, rhs);
		return retval;
	}
	
	public soot.Value ModExpr.emit(Body b) {
		Local lhs = this.getLeftOperandLocal(b);
		Local rhs = this.getRightOperandLocal(b);
		soot.jimple.RemExpr retval = Jimple.v().newRemExpr(lhs, rhs);
		return retval;
	}
	
	public soot.Value LShiftExpr.emit(Body b) {
		Local lhs = this.getLeftOperandLocal(b);
		Local rhs = this.getRightOperandLocal(b);
		soot.jimple.ShlExpr retval = Jimple.v().newShlExpr(lhs, rhs);
		return retval;
	}
	
	public soot.Value RShiftExpr.emit(Body b) {
		Local lhs = this.getLeftOperandLocal(b);
		Local rhs = this.getRightOperandLocal(b);
		soot.jimple.ShrExpr retval = Jimple.v().newShrExpr(lhs, rhs);
		return retval;
	}
	
	//NOTE: No Unsigned Shift Left definition in Java.
	
	public soot.Value URShiftExpr.emit(Body b) {
		Local lhs = this.getLeftOperandLocal(b);
		Local rhs = this.getRightOperandLocal(b);
		soot.jimple.UshrExpr retval = Jimple.v().newUshrExpr(lhs, rhs);
		return retval;
	}
	
	public soot.Value OrBitwiseExpr.emit(Body b) {
		Local lhs = this.getLeftOperandLocal(b);
		Local rhs = this.getRightOperandLocal(b);
		soot.jimple.OrExpr retval = Jimple.v().newOrExpr(lhs, rhs);
		return retval;
	}
	
	public soot.Value AndBitwiseExpr.emit(Body b) {
		Local lhs = this.getLeftOperandLocal(b);
		Local rhs = this.getRightOperandLocal(b);
		soot.jimple.AndExpr retval = Jimple.v().newAndExpr(lhs, rhs);
		return retval;
	}
	
	public soot.Value XorBitwiseExpr.emit(Body b) {
		Local lhs = this.getLeftOperandLocal(b);
		Local rhs = this.getRightOperandLocal(b);
		soot.jimple.XorExpr retval = Jimple.v().newXorExpr(lhs, rhs);
		return retval;
	}
	
	/*
	public soot.Value AssingPlusExpr.emit(Body b) {
		Local dest = this.getDst();
	}
	*/

	//general case for accesses...
	public soot.Value AbstractDot.emit(Body b) {
		return lastAccess().emit(b);
	}
	
	// you just encounter a variable...
	public soot.Value VarAccess.emit(Body b) {
		Variable var = this.decl();
		//I can't believe this distinction is made...
		if (var instanceof VariableDeclarator) {
			System.out.println("variable");
			VariableDeclarator decl = (VariableDeclarator)var;
			//TODO: host thing...
			return decl.local;
		}
		else if (var instanceof ParameterDeclaration) {
			ParameterDeclaration decl = (ParameterDeclaration)var;
			//TODO: host thing...
			System.out.println("param");
			return decl.local;
		}
		else if (var instanceof FieldDeclarator) {
			//TODO: 
		}
		else {
		//TODO:
		}
		
		//Just for now...
		return null;
	}
	
	
	

	/*
	public soot.Value AssignSimpleExpr.emit(Body b) {
		Value lvalue = getDest().emit(b);
		//I don't really understand this line. I am thinking it has to do with type analysis...
		Value rvalue = asRValue(b,
			getSource().type().emitCastTo(b,
				getSource(),
				getDest().type()
			)
		);
		return getDest().emitStore(b, lvalue, asImmediate(b, rvalue), this);
	}*/
	
	//compound assign expression
	/*
	public soot.Value AssignExpr.emit(Body b) {
		TypeDecl dest = getDest().type();
		TypeDecl source = getSource().type();
		boolean needsNumericPromotion = dest.isNumericType() && source.isNumericType();
		TypeDecl type = needsNumericPromotion ? dest.binaryNumericPromotion(source) : dest;
		// are you emituating an identifier?
		Value lvalue = getDest().emit(b);
		// if you are local I can modify you easily, if not that means you are a global and cloning is better?
		Value v = lvalue instanceof Local ? lvalue : (Value)lvalue.clone();
		Value value = b.newTemp(dest.emitCastTo(b, v, type, this));
		Value rvalue = source.emitCastTo(b, getSource(), type);
		Value result = asImmediate(b, type.emitCastTo(b,
			createAssignOp(b, value, rvalue),
			dest,
			getDest()
		));
		getDest().emitStore(b, lvalue, result, this);
		return result;
	}*/
	
}