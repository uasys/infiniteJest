import soot.*;
import java.io.*;
import soot.options.*;
import soot.Scene;
import soot.jimple.*;
import soot.util.*;

aspect InfiniteJast {

  public void CompilationUnit.process()  {
	if (this.fromSource()) {
		this.jimplify(null);
	}
  }
  
  public <T> void ASTNode.jimplify(T c) {
  	for(int i = 0; i < getNumChild(); i++) {
  		getChild(i).jimplify(c);
  	}
  }
  
  syn lazy SootClass TypeDecl.getSootClassDecl() {
  	if (compilationUnit().fromSource()) { return this.sootClass(); }
  	
  	//if (this.options().verbose()) { System.out.println("Loading .class file " + this.jvmName()); }
  	
  	SootClass sc = Scene.v().loadClass(this.jvmName(), SootClass.SIGNATURES);
  	sc.setLibraryClass();
  	return sc;
  }
  
  syn lazy SootClass TypeDecl.sootClass() = null;
  eq ClassDecl.sootClass() {
  	//if (this.options().verbose()) { System.out.println("Creating from source " + this.jvmName()); }
  	
  	//SootClass sc = new SootClass(this.jvmName()
  	return null;
  }
  
  eq ArrayDecl.getSootClassDecl() = typeObject().getSootClassDecl();
  
  public <T> void ClassDecl.jimplify(T _sClass) {
  	SootClass incoming = null;

  	//do I need to always load and support java.lang.Object and java.lang.System?
  	Scene.v().loadClassAndSupport("java.lang.Object");
    Scene.v().loadClassAndSupport("java.lang.System");
    SootClass sClass = new SootClass(this.jvmName(), this.flags());
    sClass.setSuperclass(Scene.v().getSootClass(this.superclass().fullName()));
    if (_sClass instanceof SootClass) {
  		incoming = (SootClass)_sClass;
  		sClass.setOuterClass(incoming);
  	}
    
    //TODO: need to add implements...
    List<Access> _implements = this.getImplementss();
    
    Scene.v().addClass(sClass);
    for(int i = 0; i < getNumChild(); i++) {
    	getChild(i).jimplify(sClass);
    	try {
    		String fileName = SourceLocator.v().getFileNameFor(sClass, soot.options.Options.output_format_jimple);
			OutputStream streamOut = new FileOutputStream(fileName);
			PrintWriter writerOut = new PrintWriter(new OutputStreamWriter(streamOut));
			Printer.v().printTo(sClass, writerOut);
			writerOut.flush();
			streamOut.close();
			/*	  
	  		JasminClass jasminClass = new soot.jimple.JasminClass(sClass);
	  		jasminClass.print(writerOut);
	  		writerOut.flush();
	  		streamOut.close();
	  		* */
		} catch (Exception e) {
			System.out.println(e.getMessage());
			System.out.println("There was an error writing the jimple file");
		}
    }
  }
  
  syn int MethodDecl.sootTypeModifiers() {
  	int result = 0;
  	if (this.isPublic())		result |= soot.Modifier.PUBLIC;
  	if (this.isProtected())		result |= soot.Modifier.PROTECTED;
  	if (this.isPrivate())		result |= soot.Modifier.PRIVATE;
  	if (this.isFinal())			result |= soot.Modifier.FINAL;
  	if (this.isStatic())		result |= soot.Modifier.STATIC;
  	if (this.isAbstract())		result |= soot.Modifier.ABSTRACT;
  	if (this.isSynchronized())	result |= soot.Modifier.SYNCHRONIZED;
  	if (this.isStrictfp())		result |= soot.Modifier.STRICTFP;
  	if (this.isNative())		result |= soot.Modifier.NATIVE;
  	return result;
  }
  
  syn int ConstructorDecl.sootTypeModifiers() {
  	int result = 0;
  	if (this.isPublic())	result |= soot.Modifier.PUBLIC;
  	if (this.isProtected())	result |= soot.Modifier.PROTECTED;
  	if (this.isPrivate())	result |= soot.Modifier.PRIVATE;
  	return result;
  }
  
  syn int FieldDeclarator.sootTypeModifiers() {
  	int result = 0;
  	if (this.isPublic()) 	result |= soot.Modifier.PUBLIC;
  	if (this.isProtected()) result |= soot.Modifier.PROTECTED;
  	if (this.isPrivate())	result |= soot.Modifier.PRIVATE;
  	if (this.isFinal())		result |= soot.Modifier.FINAL;
  	if (this.isStatic())	result |= soot.Modifier.STATIC;
  	return result;
  }
  
  public SootField FieldDeclarator.sootField = null;
  
  public <T> void FieldDeclarator.jimplify(T _sClass) {
  	if (!(_sClass instanceof SootClass)) {
  		for(int i = 0; i < getNumChild(); i++) {
  			getChild(i).jimplify(_sClass);
  		}
  		return;
  	}
  	
  	SootClass sClass = (SootClass)_sClass;
  	String name = this.name();
  	soot.Type type = this.type().sootType();
  	int modifiers = this.sootTypeModifiers();
  	boolean thisClassDeclaresThisField = !this.hostType().getSootClassDecl().declaresFieldByName(name);
  	
	if (!thisClassDeclaresThisField) {
		this.sootField = hostType().getSootClassDecl().getFieldByName(name);
		//addAttributes()
		return;
	}
	
  	SootField f = new SootField(name, type, modifiers);
  	boolean fieldIsStaticFinalConstantBuiltinType = this.isStatic() &&
  													this.isFinal() &&
  													this.isConstant() &&
  													(this.type().isPrimitive() || this.type().isString());
  	if (!fieldIsStaticFinalConstantBuiltinType) {
  		this.sootField = f;
  		//addAttributes();
  		return;
  	}
  	
  	if (this.type().isString()) {
  		f.addTag(new soot.tagkit.StringConstantValueTag(constant().stringValue()));
  	} else if (this.type().isLong()) {
  		f.addTag(new soot.tagkit.LongConstantValueTag(constant().longValue()));
  	} else if (this.type().isDouble()) {
  		f.addTag(new soot.tagkit.DoubleConstantValueTag(constant().doubleValue()));
  	} else if (this.type().isFloat()) {
  		f.addTag(new soot.tagkit.FloatConstantValueTag(constant().floatValue()));
  	} else if (this.type().isIntegralType()) {
  		f.addTag(new soot.tagkit.IntegerConstantValueTag(constant().intValue()));
  	}
  	
  	this.sootField = f;
  	//addAttributes();
  	return;
  }
  

  public <T> void MethodDecl.jimplify(T _sClass) {
  	if (!(_sClass instanceof SootClass)) {
  		for(int i = 0; i < getNumChild(); i++) {
  			getChild(i).jimplify(_sClass);
  		}
  		return;
  	}
  	
  	SootClass sClass = (SootClass)_sClass;
 	//TODO: Exceptions....
 	java.util.LinkedHashMap<Local, Type> params = this.getParametersSoot();
 	java.util.List<Type> types = new ArrayList<Type>(params.values());
 	SootMethod method = new SootMethod(this.name(), types, this.type().sootType(), this.flags());
   	sClass.addMethod(method);
   	JimpleBody body = Jimple.v().newBody(method);
    method.setActiveBody(body);
    this.addParamsToBody(body, params);
	for(int i = 0; i < getNumChild(); i++) {
  		getChild(i).jimplify(body);
  	}
  }
  
  //TODO: add dimensions...
  public <T> void VariableDeclarator.jimplify(T _body) {
  	if (!(_body instanceof JimpleBody)) {
  		for (int i = 0; i < getNumChild(); i++) {
  			getChild(i).jimplify(_body);
  		}
  		return;
  	}
  	Expr init = this.getInit();
  	JimpleBody body = (JimpleBody)_body;
  	Local newLocal = Jimple.v().newLocal(this.name(), this.type().sootType());
  	body.getLocals().add(newLocal);
  	if (this.hasInit()) {
  		soot.Value rval = init.emit(body);
  		Chain units = body.getUnits();
  		units.add(Jimple.v().newAssignStmt(newLocal, rval));
  	}
  	this.local = newLocal;
  }
  
  public <T> void ReturnStmt.jimplify(T _units) {
  	if (!(_units instanceof Chain)) {
  		for (int i = 0; i < getNumChild(); i++) {
  			getChild(i).jimplify(_units);
  		}
  		return;
  	}
  	Chain units = (Chain)_units;
  	units.add(Jimple.v().newReturnVoidStmt());
	for(int i = 0; i < getNumChild(); i++) {
		getChild(i).jimplify(units);
	}
  }
  
  public Local VariableDeclarator.local = null;
  public Local ParameterDeclaration.local = null;
  /*
  public <T> void Stmt.jimplify(T _units) {
  	if (!(_units instanceof Chain)) {
  		for(int i = 0; i < getNumChild(); i++) {
  			getChild(i).jimplify(_units);
  		}
  	}
  	Chain units = (Chain)_units;
  }
*/
}