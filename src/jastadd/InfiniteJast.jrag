import soot.*;
import java.io.*;
import soot.options.*;
import soot.Scene;
import soot.jimple.*;
import soot.util.*;

aspect InfiniteJast {

  public void CompilationUnit.process()  {
	if (this.fromSource()) {
		this.jimplify(null);
	}
  }
  
  public <T> void ASTNode.jimplify(T c) {
  	for(int i = 0; i < getNumChild(); i++) {
  		getChild(i).jimplify(c);
  	}
  }
  
  public <T> void ClassDecl.jimplify(T _sClass) {
  	SootClass incoming = null;

  	//do I need to always load and support java.lang.Object and java.lang.System?
  	Scene.v().loadClassAndSupport("java.lang.Object");
    Scene.v().loadClassAndSupport("java.lang.System");
    SootClass sClass = new SootClass(this.jvmName(), this.flags());
    sClass.setSuperclass(Scene.v().getSootClass(this.superclass().fullName()));
    if (_sClass instanceof SootClass) {
  		incoming = (SootClass)_sClass;
  		sClass.setOuterClass(incoming);
  	}
    
    //TODO: need to add implements...
    List<Access> _implements = this.getImplementss();
    
    Scene.v().addClass(sClass);
    for(int i = 0; i < getNumChild(); i++) {
    	getChild(i).jimplify(sClass);
    	try {
    		String fileName = SourceLocator.v().getFileNameFor(sClass, soot.options.Options.output_format_jimple);
			OutputStream streamOut = new FileOutputStream(fileName);
			PrintWriter writerOut = new PrintWriter(new OutputStreamWriter(streamOut));
			Printer.v().printTo(sClass, writerOut);
			writerOut.flush();
			streamOut.close();
		} catch (Exception e) {
			System.out.println("There was an error writing the jimple file");
		}
    }
  }
  
  syn soot.Type ArrayDecl.sootType() {
  	//TODO: not actually true for Reference types... right?
  	return RefType.v(this.typeName());
  }

  syn soot.Type TypeDecl.sootType() {
  	return this.isReferenceType() ? RefType.v(this.jvmName()) : RefType.v(this.typeName());
  }
  
  syn java.util.List<Type> MethodDecl.getParameterListSoot() {
  	List<ParameterDeclaration> params = this.getParameterList();
  	java.util.List<Type> sootParams = new ArrayList<Type>();
  	for (ParameterDeclaration param : params) {
  		sootParams.add(param.type().sootType());
  	}
  	return sootParams;
  }
  
  public <T> void MethodDecl.jimplify(T _sClass) {
  	if (!(_sClass instanceof SootClass)) {
  		for(int i = 0; i < getNumChild(); i++) {
  			getChild(i).jimplify(_sClass);
  		}
  	}
  	
  	SootClass sClass = (SootClass)_sClass;
 	List<ParameterDeclaration> params = this.getParameterList(); 
 	//TODO: Exceptions....
 	SootMethod method = new SootMethod(this.name(),
		this.getParameterListSoot(),
    	this.type().sootType(), this.flags());
   	sClass.addMethod(method);
   	JimpleBody body = Jimple.v().newBody(method);
    method.setActiveBody(body);
	for(int i = 0; i < getNumChild(); i++) {
  		getChild(i).jimplify(body);
  	}
  }

  public <T> void Block.jimplify(T _body) {
    if (!(_body instanceof JimpleBody)) {
  		for(int i = 0; i < getNumChild(); i++) {
  			getChild(i).jimplify(_body);
  		}
  	}
  	JimpleBody body = (JimpleBody)_body;
  	Chain units = body.getUnits();
	for(int i = 0; i < getNumChild(); i++) {
  		getChild(i).jimplify(units);
  	}
  }
  
  public <T> void Stmt.jimplify(T _units) {
  	if (!(_units instanceof Chain)) {
  		for(int i = 0; i < getNumChild(); i++) {
  			getChild(i).jimplify(_units);
  		}
  	}
  	Chain units = (Chain)_units;
  }

}